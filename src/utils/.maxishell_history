hu=huh
hÂ£u=ytuy
hu=UH78&
a=123
a&2=fhvhrtiyug
a==123
=uyyfgh
exit
ls
clear
a=123
exit
a=123
$a
a=123
$a
ls
a=123
a=fglkjh45
$a
echo $a
exit
a=123
ab=123
exit
a=123
=123
A=123
echo $_
a=123
a=123
exit
a=123
a=123
exit
a=123
a=123
a=123
a=123
a=123
exit
a=123
exit
a=123
exit
a=123
exit
a=123
exit
a=123
exit
a=123
exit
a=123
a=123
a=321
$a
exit
a=321
https://www.youtube.com/watch?v=YqXYmQDMitE
https://www.youtube.com/watch?v=YqXYmQDMitE
[200~readline(loop_data->prompt);
I have this prompt:
ðŸŒ´ rmikhayl@maxishell$ 
when I paste in 
https://www.youtube.com/watch?v=YqXYmQDMitE
and try to delete it without executing it in my minishell, 
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
exit
char *generate_prompt(t_ms_data *data) {
    char *prompt;
    size_t prompt_len;
    prompt_len = ft_strlen("ðŸŒ´\\[\\e[1m\\] @maxishell$ \\[\\e[m\\]") + \
                 ft_strlen(getenv("LOGNAME"));
    prompt = (char *)malloc(prompt_len + 1);  // +1 for null-terminator
    if (!prompt)
        exit(EXIT_FAILURE);
    // Use double backslashes to properly escape them in the C string
    ft_strcpy(prompt, "ðŸŒ´\\[\\e[1m\\] ");
    ft_strcat(prompt, getenv("LOGNAME"));
    ft_strcat(prompt, "@maxishell$ \\[\\e[m\\]");
    (void)data;
    return prompt;
}
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
ðŸŒ´\[\e[1m\] rmikhayl@maxishell$ \[\e[
exit
exit
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
exit
exit
exit
https://www.youtube.com/watch?v=YqXYmQDMit
exit
exit
exit
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
exit
char *generate_prompt(t_ms_data *data) {
    char *prompt;
    size_t prompt_len;
    // Calculate the length for the prompt, taking into account the escape sequences
    prompt_len = ft_strlen("ðŸŒ´ ") + ft_strlen(getenv("LOGNAME")) + ft_strlen("@maxishell$ ") + 18;
    prompt = (char *)malloc(prompt_len + 1);  // +1 for null-terminator
    if (!prompt)
        exit(EXIT_FAILURE);
    // Build the prompt string with ANSI escape sequences for formatting
    ft_strcpy(prompt, "ðŸŒ´");  // Start with bold formatting
    ft_strcat(prompt, getenv("LOGNAME"));
    ft_strcat(prompt, "@maxishell$ ");  // Reset formatting to normal
	(void)data;
    return prompt;
}
exit
exit
ff
exit
htxit
exit
exit
exit
exit
exit
exit
hgf
eit
exit
exit
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
./minishell 
https://www.youtube.com/watch?v=YqX
https://www.youtube.com/watch?v=YqX
exit
char *generate_prompt(t_ms_data *data)
{
    char *prompt;
    size_t prompt_len;
    // Adjust prompt length to account for escape sequences and markers
    prompt_len = ft_strlen("ðŸŒ´\\[\\e[1m\\] @maxishell$ \\[\\e[m\\]") + \
                 ft_strlen(getenv("LOGNAME"));
    
    // Allocate memory for the prompt string
    prompt = (char *)malloc(prompt_len + 1);  // +1 for null-terminator
    if (!prompt)
        exit(EXIT_FAILURE);
    
    // Build the prompt string with proper handling of escape sequences
    ft_strcpy(prompt, "ðŸŒ´\\[\\e[1m\\] ");
    ft_strcat(prompt, getenv("LOGNAME"));
    ft_strcat(prompt, "@maxishell$ \\[\\e[m\\]");
    (void)data;
    return prompt;
}
https://www.youtube.com/watch?v=YqXYmQDMitE
exit
exit
exit
ls
exit
exit
rugh
exit
echo hello
exit
echo hello
EXIT
exit
echo hello
exit
echo hello
exit
